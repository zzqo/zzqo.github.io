<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring与SpringMVC的容器冲突解决]]></title>
    <url>%2Fp%2F69d4.html</url>
    <content type="text"><![CDATA[博客园1.在applicationContext.xml中配置:12345&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;&lt;context:component-scan base-package="com.hafiz.www"&gt; &lt;!--排除@Controller--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; 2.applicationContext-MVC.xml中配置1234567&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;&lt;!--use-default-filters：默认true 会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描 这里改为false让其只扫描@Controller注解--&gt;&lt;context:component-scan base-package="com.hafiz.www" use-default-filters="false"&gt; &lt;!--引入@Controller--&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;&lt;/context:component-scan&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列1,11,21,1211,111221]]></title>
    <url>%2Fp%2Fa79b.html</url>
    <content type="text"><![CDATA[1. 序列1，11，21，1211，111221，_，下一个数是什么？答：312211 1 读为： 1个1，提取数字11（即为第二个数）； 11 读为： 2个1，提取数字21（即为第三个数）； 21 读为： 1个2、1个1，提取数字1211（即为第四个数）； 1211 读为：1个1、1个2、2个1；提取数字111221（即为第四个数）； 2. 编程实现123456789101112131415161718192021222324252627282930313233public class Demo &#123; public static void main(String[] args) &#123; int count = 6; String[] str = new String[count]; str[0] = "1"; str[1] = "11"; int j; StringBuilder result; for (int i = 2; i &lt; count; i++) &#123; char[] pri = str[i - 1].toCharArray(); int n; result = new StringBuilder(); j = 0; for (n = 0; n &lt; pri.length - 1; n++) &#123; if (pri[n] == pri[n + 1]) &#123; j++; &#125; else &#123; j++; result.append(j); result.append(pri[n]); j = 0; &#125; &#125; j++; result.append(j); result.append(pri[n]); str[i] = result.toString(); &#125; for (int i = 1; i &lt;= count; i++) &#123; System.out.println(i + "个数: " + str[i-1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类中的初始化顺序]]></title>
    <url>%2Fp%2F66fe.html</url>
    <content type="text"><![CDATA[1. 下面详细介绍了类中变量的初始化顺序1234567891011121314151617181920212223242526272829303132public class Test &#123; // 1.第一步，准备加载类 static int num = 4; // 2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 static &#123; // 3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a System.out.println("a"); &#125; public static void main(String[] args) &#123; new Test(); // 4.第四步，new一个类，但在new之前要处理匿名代码块 &#125; int a = 4; // 5.第五步，按照顺序加载变量和执行匿名代码块 &#123; System.out.println("b"); // 6.第六步，按照顺序加载匿名代码块，代码块中有打印 &#125; int b = 5; // 7.第七步，按照顺序加载变量 &#123; System.out.println("c"); // 8.第八步，按照顺序打印c &#125; Test() &#123; System.out.println("d"); // 9.第久步，最后加载构造函数，完成对象的建立 &#125; static void run() &#123; // 静态方法，调用的时候才加载// 注意看，e没有加载 System.out.println("e"); &#125;&#125; 2. 一个简单的小测试1234567891011121314151617181920212223242526272829303132333435363738public class TestAB &#123; public static void main(String[] args) &#123; // 142356 B b = new B(); &#125;&#125;class A &#123; static int a = 4; static &#123; System.out.print(1); &#125; &#123; System.out.print("2"); &#125; public A() &#123; System.out.print(3); &#125;&#125;class B extends A &#123; static int a = 5; static &#123; System.out.print(4); &#125; &#123; System.out.print("5"); &#125; public B() &#123; System.out.print(6); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8四大内置核心函数式接口]]></title>
    <url>%2Fp%2Fd0ca.html</url>
    <content type="text"><![CDATA[JDK8 中的四大核心函数式接口 @FunctionalInterface标记在接口上，“函数式接口”是指仅仅只包含一个抽象方法的接口1. Consumer：消费型接口 void accpt(T t); 12345678910public class ConsumerTest &#123; @Test public void test() &#123; happy(1000d, (money) -&gt; System.out.println("今天消费了" + money + "元")); &#125; public static void happy(Double money, Consumer&lt;Double&gt; customer) &#123; customer.accept(money); &#125;&#125; 2. Supplier：供给型接口 T get(); 1234567891011121314151617181920212223public class SupplierTest &#123; @Test public void test() &#123; //生成10个100以内的随机数 List&lt;Integer&gt; list = getNumList(10, () -&gt; (int) (Math.random() * 100)); list.forEach(System.out::println); &#125; /** * 产生指定个数的随机数放入集合中并返回 * * @param num 生成随机数的个数 * @param supplier 供给型接口 * @return List */ public static List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; supplier) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; list.add(supplier.get()); &#125; return list; &#125;&#125; 3. Function：函数式接口 R apply(T t); 12345678910111213141516public class FunctionTest &#123; @Test public void test1() &#123; System.out.println(strHandler("hello world !", (str)-&gt;str.toUpperCase())); &#125; @Test public void test2() &#123; // 类::实例方法名 System.out.println(strHandler("hello world !",String::toUpperCase)); &#125; public static String strHandler(String str, Function&lt;String, String&gt; function) &#123; return function.apply(str); &#125;&#125; 4. Predicate：消费型接口 boolean test(T t); 1234567891011121314151617181920212223242526public class PredicateTest &#123; @Test public void test() &#123; List&lt;String&gt; list = Arrays.asList("hello java", "C#", "C++", "jar", "java"); // 判断集合中是否包含 java 包含就添加进新的集合并返回 List&lt;String&gt; stringList = filterStr(list, (str) -&gt; str.contains("java")); stringList.forEach(System.out::println); &#125; /** * 将满足条件的字符串放进新的集合中并返回 * * @param list List * @param predicate 断言型接口 * @return List */ public static List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; predicate) &#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if (predicate.test(str)) &#123; strList.add(str); &#125; &#125; return strList; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finalize方法之对象的自我拯救]]></title>
    <url>%2Fp%2Fc96a.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 对象的自我拯救 * 被拯救后的对象信息丢失,但是对象的地址值不变 * * @author ZZQ */public class FinalizeEscapeGC &#123; private String name; public static FinalizeEscapeGC SAVE_HOOK = null; /** * 判断是否还活着 */ public void isAlive() &#123; System.out.println(SAVE_HOOK.name + "还活着"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("finalize方法执行了"); // 与对象建立联系，自救 FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGC(); SAVE_HOOK.name = "zzq"; System.out.println("被拯救前对象地址值：" + SAVE_HOOK); //第一次自救 SAVE_HOOK = null; System.gc(); //因为finalize的优先级低，先等一下 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("第一次自救失败"); &#125; System.out.println("被拯救后对象地址值：" + SAVE_HOOK); //第二次自救 //因为每个对象的finalize()方法只会被系统自动调用一次，所以第一次调用后， //第二次自救时不会再调用finalize(),自然也就不会与其他的对象产生联系，从而自救失败 SAVE_HOOK = null; System.gc(); //因为finalize的优先级低，先等一下 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("第二次自救失败"); &#125; &#125; //finalize()虽然能够实现对象自救，但是不要轻易使用，因为他的运行代价太大，不确定性高，无法确定各个对象的调用顺序。 //而且finalize()能做的事，try-finally都能做，而且做得更好&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的4种创建方式]]></title>
    <url>%2Fp%2F424a.html</url>
    <content type="text"><![CDATA[1. 继承Thread类 123456789101112131415public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t = new Thread(myThread); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 2. 实现Runnable接口123456789101112131415public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t = new Thread(myThread); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 3. 使用Callable和Future创建线程123456789101112131415161718public class ThreadDemo &#123; public static void main(String[] args) &#123; MyCallable myCallable = new MyCallable(); FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(myThread); Thread t = new Thread(future); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return 0; &#125;&#125; 4. 使用线程池创建线程1234567891011121314151617181920212223public class ThreadDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 创建一个具有固定大小的线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建一个任务 Callable&lt;Integer&gt; callable = new MyCallable(); // 提交任务 Future future = executorService.submit(callable); // 获取任务执行结果 此方法会阻塞 System.out.println(future.get()); // 关闭线程池 executorService.shutdown(); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return 0; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
