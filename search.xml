<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[福建拓展宝科技有限公司2019面试题]]></title>
    <url>%2Fp%2Ff17f.html</url>
    <content type="text"><![CDATA[根据aa表写出对应的查询结果 rq shengfu 2018-10-01 胜 2018-10-01 胜 2018-10-01 负 2018-10-01 负 2018-10-20 胜 2018-10-20 胜 2018-10-20 负 2018-10-20 负 查询结果： rq 胜 负 2018-10-01 2 2 2018-10-01 2 2 答：1SELECT rq,sum(shenfu=&quot;胜&quot;) 胜,sum(shenfu=&quot;负&quot;) 负 FROM aa GROUP BY rq 1234SELECT rq, COUNT( CASE WHEN shenfu = &apos;胜&apos; THEN &apos;胜&apos;END ) 胜, COUNT( CASE WHEN shenfu = &apos;负&apos; THEN &apos;负&apos;END ) 负FROM aa GROUP BY rq in 和 exists 区别 in()适合B表比A表数据小的情况 exists()适合B表比A表数据大的情况 当A表数据与B表数据一样大时,in与exists效率差不多,可任选一个使用.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[福州新雅图网络科技有限公司2019面试题]]></title>
    <url>%2Fp%2F8b79.html</url>
    <content type="text"><![CDATA[面试时间： 2019-4-19 byte b = (byte) 128;答：b为-128 byte a = (byte) 127; 127 byte b = (byte) 128; -128 byte c = (byte) 129; -127 byte d = (byte) 130; -126 使用两种方法遍历map集合 1234567891011121314151617public class Demo&#123;public static void main(String[] args) &#123; Map&lt;Integer, Integer&gt; map = new HashedMap&lt;Integer, Integer&gt;() &#123; &#123; put(1, 1); put(2, 2); put(3, 3); &#125; &#125;; for (Integer key : map.keySet()) &#123; System.out.println(map.get(key)); &#125; for (Map.Entry entry : map.entrySet()) &#123; System.out.println(entry.getKey()+" "+entry.getValue()); &#125; &#125;&#125; 将d:\\src下的a.txt文件复制到e:\\src下 12345678910111213141516171819202122232425262728293031323334353637public class CopyFile &#123; public static void main(String[] args) &#123; // 方式一 File file = new File("E:/src/a.mp4"); File dir = new File("D:/src/"); if (!dir.exists()) &#123; if (!dir.mkdirs()) &#123; throw new RuntimeException("文件夹创建失败"); &#125; else &#123; if (file.renameTo(new File("D:/src/a.mp4"))) &#123; System.out.println("移动完成！"); &#125; else &#123; System.out.println("移动失败！"); &#125; &#125; &#125; // 方式二 Path path1 = Paths.get("D:/src/a.mp4"); Path path2 = Paths.get("E:/src/a.mp4"); Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING); // 方式三 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); try (FileChannel inChannel = FileChannel.open(Paths.get("D:/src/a.mp4"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("E:/src/a.mp4"), StandardOpenOption.CREATE, StandardOpenOption.WRITE) ) &#123; while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); outChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成都精准云教育科技有限公司2019面试题]]></title>
    <url>%2Fp%2F4f20.html</url>
    <content type="text"><![CDATA[面试时间： 2019-4-8 一、单选题 下列哪一种叙述是正确的(D)A. abstract 修饰符可修饰字段、方法和类B. 抽象方法的 body 部分必须用一对大括号 {} 包住C. 声明抽象方法，大括号可有可无D. 声明抽象方法不可写出大括号 如下代码(D)A. 0B. 1C. 2D. 编译失败 1234567891011121314public class Test &#123; public int aMethod() &#123; static int i = 0; i++; return i; &#125; public static void main(String args[]) &#123; Test test = new Test(); test.aMethod(); int j = test.aMethod(); System.out.println(j); &#125;&#125; 下列哪种说法是正确的(D)A. 实例方法可直接调用超类的实例方法B. 实例方法可直接调用超类的类方法C. 实例方法可直接调用其他类的实例方法D. 实例方法可直接调用本类的类方法 如下代码(E)A. 4,4B. 4,5C. 5,4D. 5,5E. 编译失败 123456789101112131415161718class Super &#123; public Integer getLength() &#123; return new Integer(4); &#125;&#125;public class Sub extends Super &#123; @Override public Long getLength() &#123; return new Long(5); &#125; public static void main(String[] args) &#123; Super sooper = new Super(); Sub sub = new Sub(); System.out.println(sooper.getLength().toString() + "," + sub.getLength().toString()); &#125;&#125; 在Servlet处理请求的方式为(C)A. 以进程的方式B. 以程序的方式C. 以线程的方式D. 以响应的方式 按照MVC设计模式，JSP用于实现(B)A. ModelB. ViewC. ControllerD. 容器 以下关于异常的说法不正确的是(D)A. 一旦出现异常，程序运行就终止了B. 如果一个方法声明将跑出某个异常，它就必须真的抛出那个异常C. 在catch子句中匹配异常是一种精准匹配D. 可能抛出系统异常的方法是不需要声明该异常的 在一个线程中Sleep（1000）方法，将使得该线程在多少时间后获得对CPU的控制（假设睡眠过程中不会有其他事件唤醒该线程）？(C)Ａ. 正好1000毫秒Ｂ. 1000毫秒不到Ｃ. =&gt;1000毫秒Ｄ. 不一定 在WEB-INF目录下，必须存放的文件为:(B)A. class文件B. web.xmlC. jar文件D. html文件 下面的语句会产生什么样的输出(A)A.4B.5C.6D.7E.0 1System.out.println(4&amp;7); 下面的程序中，temp的最终值是什么(B)A. 0B. 1C. 2D. 3E. 4 1long temp=(int)3.9; temp%=2; 下面哪个不是JAVA关键字(A)A. integerB. doubleC. floatD. default 下列关于构造方法的叙述中，错误的是(C)A. Java语言规定构造方法名与类名必须相同B. Java语言规定构造方法没有返回值，但不用vold声明C. Java语言规定构造方法不可以重载D. Java语言规定构造方法只能通过new自动调用 构造函数何时被调用(B)A. 类定义时B. 创建对象时C. 调用对象方法时D. 使用对象的变量时 break语句(D)A. 只中断最内层的循环B. 只中断最外层的循环C. 借助于标号，可以实现任何外层循环中断D. 只中断某一层的循环 Java语言中下面哪个可以用作正确的变量名称(B)A. 3DB. nameC. extendsD. implements 二、简答题 Java有哪些基本数据类型，String是不是基本数据类型，他们有何区别 byte、short、int、long、char、boolean、float 基本数据类型（如int,boolean,double等）与String的区别在于内存。String是以数组存放的，数组的每一个内容表示字符串的一个字符；int等变量是用几个字节存放的，几种基本类型无非就是字节数量不同而已。 数组和集合的区别 数组的特点a.数组本质上就是一段连续的内存空间，用于记录多个类型相同的数据b.数组一旦声明完毕，则内存空间固定不变c.插入和删除操作不方便，可能会移动大量的元素导致效率太低d.支持下标访问，可以实现随机访问e.数组中的元素可以是基本数据类型，也可以使用引用数据类型 集合的特点a.内存空间可以不连续，数据类型可以不相同b.集合的内存空间可以动态地调整c.集合的插入删除操作可以不移动大量元素d.部分支持下标访问，部分不支持e.集合中的元素必须是引用数据类型 使用StringBuffer类和String类进行字符串拼接时有何区别？ StringBuffer是在内存开辟一块存储空间,在里面可以增加字符,如果满了的话,再增加存储空间 String是一个常量,进行连接时,会创建一个新的String对象,如果进行连接很频繁的话用StringBuffer,String的效率比较低 谈谈 final，finally，finalize的区别 final：如果一个类被final修饰，意味着该类不能派生出新的子类，不能作为父类被继承。因此一个类不能被声明为abstract，又被声明为final。将变量或方法声明为final。可以保证他们在使用的时候不被改变。其初始化可以在两个地方：一是其定义的地方，也就是在final变量在定义的时候就对其赋值；二是在构造函数中。这两个地方只能选其中的一个，要么在定义的时候给值，要么在构造函数中给值。被声明为final的方法也只能使用，不能重写。 finally：在异常处理的时候，提供finally块来执行任何的清除操作。如果抛出一个异常，那么相匹配的catch字句就会执行，然后控制就会进入finally块，前提是有finally块。 finalize：finalize是方法名，java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是在垃圾收集器确认一个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此，所有的类都继承了它。子类覆盖finalize()方法已整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 String s = new String(“xyz”);创建了几个String Object？ 两个(一个是“xyz”,一个是指向“xyz”的引用对象s) 数组有没有length()这个方法？String有没有length()这个方法？ 数组只有length属性，String有length()方法 float型float f=3.4是否正确？ 答案： 不正确 原因： 精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4 或float f = 3.4f在java里面，没小数点的默认是int,有小数点的默认是 double;编译器可以自动向上转型，如int 转成 long 系统自动转换没有问题，因为后者精度更高double 转成 float 就不能自动做了，所以后面的加上个 f; short s1=1;s1=s1+1;有什么错？ short s1=1;s1+=1;有什么错？ short s1 = 1;s1 = s1 + 1;错误！java中整型默认为int型，s1+1结果为int型，有一个short-&gt;int的自动类型转换的过程，而int不会自动转换为精度更低的short型 short s1 = 1; s1 += 1;正确！ 执行s1+=1;其实执行的是s1 = (short) (s1 + 1); 其中会有一个强制转换的过程。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成都热土科技有限公司2019面试题]]></title>
    <url>%2Fp%2Fc88f.html</url>
    <content type="text"><![CDATA[面试时间： 2019-3-29 1. java多态定义及优点定义：1父类型 对象名= new 子类型 优点： 提高了代码的维护性(继承保证) 提高了代码的扩展性(由多态保证) 把不同的子类对象都当做父类类型来看待，可以屏蔽不同子类对象之间的实现差异，从而写出通用的代码达到通用编程，以适应需求的不断变化。 2.指出下面程序的运行结果1234567891011121314151617181920212223242526// 执行结果：1a2b2b// 说明：先执行父类静态代码块，再执行子类静态代码块，又先执行父类构造，再执行子类构造public class Hello &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125;&#125;class A&#123; static &#123; System.out.print("1"); &#125; public A() &#123; System.out.print("2"); &#125;&#125;class B extends A&#123; static &#123; System.out.print("a"); &#125; public B() &#123; System.out.print("b"); &#125;&#125; 3.下面程序打印结果1234567891011121314151617181920212223242526// 执行结果：//try//finally//100public class TryTest &#123; public static void main(String[] args) &#123; System.out.println(test()); &#125; private static int test() &#123; int num = 10; try &#123; System.out.println("try"); return num += 10; &#125; catch (Exception e) &#123; System.out.println("error"); &#125; finally &#123; if (num &gt; 20) &#123; System.out.println("num&gt;20:" + num); &#125; System.out.println("finally"); num = 100; return num; &#125; &#125;&#125; 4. 实现一个线程安全的单例模式，至少使用两种方法懒汉式单例12345678910111213141516171819public class LazySingleton &#123; // 私有静态对象,加载时候不做初始化 private static LazySingleton singleton =null; // 私有构造方法,避免外部创建实例 private LazySingleton()&#123; &#125; /** * 静态工厂方法,返回此类的唯一实例. * 当发现实例没有初始化的时候,才初始化. * @return LazySingleton */ public static synchronized LazySingleton getInstance()&#123; if(singleton ==null)&#123; singleton =new LazySingleton(); &#125; return singleton; &#125;&#125; 饿汉式单例12345678910111213141516public class EagerSingleton &#123; // 私有的唯一实例成员,在类加载的时候就创建好了单例对象 private static final EagerSingleton SINGLETON = new EagerSingleton(); //私有构造方法,避免外部创建实例 private EagerSingleton() &#123; &#125; /** * 静态工厂方法,返回此类的唯一实例. * * @return EagerSingleton */ public static EagerSingleton getInstance() &#123; return SINGLETON; &#125;&#125; 5. 冒泡排序实现12345678910111213141516// 执行结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;5, 2, 1, 3, 6, 4, 9, 8, 7&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; if (arr[i] &lt; arr[j]) &#123; int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125;&#125; 6. 生产消费者CSDN 生产者：往一个公共的盒子里面放苹果 消费者：从公共的盒子里面取苹果 盒子：盒子的容量不能超过5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public class ProducerAndCustomerLockTest &#123; public static void main(String[] args) &#123; // 创建一个盒子 Box box = new Box(); // 创建一个生产者 Producer producer = new Producer(box); // 创建一个消费者 Customer customer = new Customer(box); new Thread(producer, "生产者A").start(); new Thread(customer, "消费者A").start(); new Thread(producer, "生产者B").start(); new Thread(customer, "消费者B").start(); &#125;&#125;/** * 苹果 */class Apple &#123; /** * 苹果编号 */ private int id; public Apple(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125;&#125;/** * 盒子 */class Box &#123; /** * 最大容量 */ private int max = 5; /** * 最小容量 */ private int min = 0; /** * 装苹果的盒子 为什么是链表 因为 它有boxs.removeFirst();方法 方便取出苹果 */ private LinkedList&lt;Apple&gt; boxs = new LinkedList&lt;&gt;(); private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); /** * 放 */ public void push(Apple apple) &#123; // 加锁 lock.lock(); try &#123; while (boxs.size() &gt;= this.max) &#123; System.out.println("盒子已满！"); try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "放苹果：" + apple.getId()); boxs.add(apple); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; /** * 取 */ public void pop() &#123; lock.lock(); try &#123; while (boxs.size() &lt;= this.min) &#123; System.out.println("盒子已空！"); try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 每次卖一个产品 System.out.println(Thread.currentThread().getName() + "取苹果：" + boxs.removeFirst().getId()); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;/** * 生产者 */class Producer implements Runnable &#123; private static Integer count = 0; private Box box; public Producer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 放苹果 box.push(new Apple(++count)); &#125; &#125;&#125;/** * 消费者 */class Customer implements Runnable &#123; private Box box; public Customer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 取苹果 box.pop(); &#125; &#125;&#125; synchronized实现生产者消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * synchronized实现生产者消费者 */public class ProducerAndCustomerLockTest &#123; public static void main(String[] args) &#123; // 创建一个盒子 Box box = new Box(); // 创建一个生产者 Producer producer = new Producer(box); // 创建一个消费者 Customer customer = new Customer(box); new Thread(producer, "生产者A").start(); new Thread(customer, "消费者A").start(); new Thread(producer, "生产者B").start(); new Thread(customer, "消费者B").start(); &#125;&#125;/** * 盒子 */class Box &#123; /** * 最大容量 */ private int max = 5; /** * 最小容量 */ private int min = 0; /** * 初始容量 */ private int product = 0; /** * 放 * * @return int */ public synchronized void get() &#123; while (product &gt;= this.max) &#123; System.out.println("盒子已满！"); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 每次进一个产品 System.out.println(Thread.currentThread().getName() + ":" + ++product); this.notifyAll(); &#125; /** * 取 */ public synchronized void sale() &#123; while (product &lt;= this.min) &#123; System.out.println("盒子已空！"); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 每次卖一个产品 System.out.println(Thread.currentThread().getName() + ":" + --product); this.notifyAll(); &#125;&#125;/** * 生产者 */class Producer implements Runnable &#123; private Box box; public Producer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 放苹果 box.get(); &#125; &#125;&#125;/** * 消费者 */class Customer implements Runnable &#123; private Box box; public Customer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 取苹果 box.sale(); &#125; &#125;&#125; Lock实现生产者消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * Lock实现生产者消费者 */public class ProducerAndCustomerLockTest &#123; public static void main(String[] args) &#123; // 创建一个盒子 Box box = new Box(); // 创建一个生产者 Producer producer = new Producer(box); // 创建一个消费者 Customer customer = new Customer(box); new Thread(producer, "生产者A").start(); new Thread(customer, "消费者A").start(); new Thread(producer, "生产者B").start(); new Thread(customer, "消费者B").start(); &#125;&#125;/** * 盒子 */class Box &#123; /** * 最大容量 */ private int max = 5; /** * 最小容量 */ private int min = 0; /** * 初始容量 */ private int product = 0; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); /** * 放 * * @return int */ public void get() &#123; // 加锁 lock.lock(); try &#123; while (product &gt;= this.max) &#123; System.out.println("盒子已满！"); try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 每次进一个产品 System.out.println(Thread.currentThread().getName() + ":" + ++product); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; /** * 取 */ public void sale() &#123; lock.lock(); try &#123; while (product &lt;= this.min) &#123; System.out.println("盒子已空！"); try &#123; condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 每次卖一个产品 System.out.println(Thread.currentThread().getName() + ":" + --product); condition.signalAll(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;/** * 生产者 */class Producer implements Runnable &#123; private Box box; public Producer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 放苹果 box.get(); &#125; &#125;&#125;/** * 消费者 */class Customer implements Runnable &#123; private Box box; public Customer(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; // 取苹果 box.sale(); &#125; &#125;&#125; 7. JavaScript实现倒计时1234567891011121314151617 &lt;script type="text/javascript"&gt; window.onload = function () &#123; var numLable = document.getElementById("numLable"); var time=setInterval(function () &#123; var num = Number.parseInt(numLable.innerHTML); if (num &gt; 0) &#123; numLable.innerHTML = (--num).toString(); &#125;else&#123; clearInterval(time); &#125; &#125;, 1000); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;label id="numLable"&gt;5&lt;/label&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成都协能共创科技有限公司2019面试题]]></title>
    <url>%2Fp%2F7ea9.html</url>
    <content type="text"><![CDATA[面试时间： 2019-4-2 一、逻辑题 1元钱一瓶汽水，喝完后两个空瓶换一瓶汽水，问：你有20元钱，最多可以喝到几瓶汽水？答： 123456782020/2 = 1010/2 = 55/2 = 2...12/2 = 11+1 = 2*2/2 = 120 + 10 + 5 +2 + 1 + 1 = 39 ABC三人都喜欢说谎话，有时候也说真话。某天，A指责B说谎话，B指责C说谎话，C说AB两人都在说谎。后来上帝通过读心术知道其中至少一个人说的是真话。请问谁在说真话？答：可以先假设A说真话，那么B是说谎的；根据B是说谎的，那么C说的是真话；而C说，AB都说谎，与A说真话相矛盾。 所以A说谎。据此，那么B说的是真话；C说的是谎话。 1，11，21，1211，111221，_，下一个数是什么？答：312211 1 读为： 1个1，提取数字11（即为第二个数）； 11 读为： 2个1，提取数字21（即为第三个数）； 21 读为： 1个2、1个1，提取数字1211（即为第四个数）； 1211 读为：1个1、1个2、2个1；提取数字111221（即为第四个数）；123456789101112131415161718192021222324252627282930313233public class Demo &#123; public static void main(String[] args) &#123; int count = 6; String[] str = new String[count]; str[0] = "1"; str[1] = "11"; int j; StringBuilder result; for (int i = 2; i &lt; count; i++) &#123; char[] pri = str[i - 1].toCharArray(); int n; result = new StringBuilder(); j = 0; for (n = 0; n &lt; pri.length - 1; n++) &#123; if (pri[n] == pri[n + 1]) &#123; j++; &#125; else &#123; j++; result.append(j); result.append(pri[n]); j = 0; &#125; &#125; j++; result.append(j); result.append(pri[n]); str[i] = result.toString(); &#125; for (int i = 1; i &lt;= count; i++) &#123; System.out.println(i + "个数: " + str[i-1]); &#125; &#125;&#125; 一个家庭有两个小孩，其中有一个是女孩，问另一个也是女孩的概率(假定生男生女的概率一样)？答：(1/21/2)/(1-1/21/2)=(1/4)/(3/4)=1/3 假设有一个池塘，里面有无穷多的水。现有2个空水壶，容积分别为5升和6升。问题是如何只用这2个水壶从池塘里取得3升的水？答： 将5L桶装满水，倒入6L桶，此时6L桶有5L水； 再次将5L桶装满水，倒入6L桶，6L水满，5L桶还剩4L水； 将6L桶的水倒空，将5L桶中剩余的4L水倒入6L桶，此时6L桶有4L水； 将5L桶再次装满水，将6L桶的水注满，5L桶剩余3L水。全过程用水15L。二、填空题 构造函数Constructor是否可被override？_答:构造器不能被继承，因此不能被重写，但可以被重载(overload) 基本数据类型包括_答：byte short int long boolean char float double static方法内部是否可以调用非static方法？答：static 方法是静态方法，是属于类的方法，非 static 方法是属于对象的方法 Java源文件中最多只能有一个_类，其他类的个数不限。答：public 是否可以继承String类？答：不可以，String类被final修饰，不可以修改 从线程安全的角度考虑，HashTable是_，HashMap是_答：安全，不安全 用_方法比较两个类型为String的字符串值是否相等答:equals() Tomcat的核心配置文件是_答：/conf/server.xml Java是通过_来处理内存分配与释放的底层操作答：jvm虚拟机(可能是此答案) final StringBuffer a = new StringBuffer(“immutable”);其中a是否可以被修改？a.append(“broken!”);是否能够编译通过？是否能执行？答: 不能被修改，可以编译通过，可以执行 三、选择题 下列说法正确的有(C)A. class中的constructor不可省略B. constructor必须与class同名，但方法不能与class同名C. constructor在一个对象被new时执行D. 一个class只能定义一个constructor 关于用关键字private修饰的成员变量，下列说法正确的是(B)A. 只能被同一个包中的其他类访问B. 只能被该类自身所访问或修饰C. 可以被其他包的类访问D. 可以被其他包中的该类的子类访问 下列关于栈的描述中错误的是(B)A. 栈是先进后出的线性表B. 栈只能顺序存储C. 栈有记忆作用D. 对栈的插入与删除操作中，不需要改变栈底指针 下列说法错误的有(BCD)A. 数组是一种对象B. 数组属于一种原生类C. int number=[]={31,23,33,43,35,61}D. 数组的大小可以任意改变 下列异常处理语句编写正确的是(D)A. try{ System.out.println(2/0);}B. try(System.out.println(2/0))catch(Exception e)(System.out.println(e.getMessage());)C. try { System.out.println(2 / 0); }D. try { System.out.println(2 / 0); }catch (Exception e){ System.out.println(e.getMessage()); } 6.如下描述正确的是(A)A. 一个java中只能有一个class是public的B. 如果一个类的构造方法是私有的，那么实例化此类就需要有一个非私有的方法C. protected的方法无法被子类访问D. abstract类不可以直接实例化 下列叙述中，正确的是(A)A. Java语言的表示度是区分大小写的B. 源文件与public类名可以不相同C. 源文件拓展名为.jarD. 源文件中public类的数目不限 下面程序的运行结果是(B)注意：java虚拟机会优化字符串拼接，String str2 = “he” + “llo”;时为trueString str1 = “hello”;String str2 = “he” + new String(“llo”);System.err.println(str1==str2);A. trueB. falseC. 编译不通过D. 产生运行时异常 下面说法正确的是(D)注意：接口不能被直接实例化，jdk9中接口中可以定义私有方法A. 用new关键字实例化接口，必须实现接口中的所有抽象放方法B. 接口中不可以定义私有方法C. 接口中可以定义私有属性D. 类可以实现多个接口 按照学生平均成绩(avg_grade)将students表中的数据检索出来，下面SQL语句正确的是(ACD)注意：分组为ORDER BY，不是GROUP BYA. SELECT FROM students ORDER BY avg_gradeB. SELECT FROM students GROUP BY avg_grade ASCC. SELECT FROM students ORDER BY avg_grade DESCD. SELECT FROM students ORDER by avg_grade asc 四、问答以及编程题 简述Overload和Override的区别Override(重写，覆盖)： 方法名、参数、返回值相同 子类方法不能缩小父类方法的访问权限 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常) 存在于父类和子类之间 方法被定义为final不能被重写Overload(重载，过载)： 参数类型、个数、顺序至少有一个不相同 不能重载只有返回值不同的方法名 存在于父类和子类、同类中 简单描述一下什么是抽象类(abstract class)和接口(interface) 一个类可以实现多个接口，但是却只能继承最多一个抽象类； 抽象类可以包含具体的方法，接口的所有方法都是抽象的； 抽象类可以声明和使用字段；接口则不能，但接口可以创静态的final常量； 接口的方法都是public的，抽象类的方法可以使public,private,protecte或者是默认的packag； 抽象类可以定义构造函数，但是接口不行。 说出下面程序运行的结果执行结果： static Astatic BI’m A classHelloAI’m B classHelloB 12345678910111213141516171819202122232425262728293031class HelloA &#123; public HelloA() &#123; System.out.println("HelloA"); &#125; &#123; System.out.println("I'm A class"); &#125; static &#123; System.out.println("static A"); &#125;&#125;public class HelloB extends HelloA &#123; public HelloB() &#123; System.out.println("HelloB"); &#125; &#123; System.out.println("I'm B class"); &#125; static &#123; System.out.println("static B"); &#125; public static void main(String[] args) &#123; new HelloB(); &#125;&#125; 第一个人10岁，第2个比第一个人大2岁，依次递推，请用递归方式计算出第8个人多大？ 123456789101112public class Demo &#123; public static void main(String[] args) &#123; System.out.println(computeAge(8)); &#125; private static int computeAge(int i) &#123; if (i == 1) &#123; return 10; &#125; return computeAge(i - 1) + 2; &#125;&#125; 请阐述一下为什么会出现以下结果答：main是主线程的线程名，Thread-1是子线程的线程名，Thread.currentThread().getName()是获得当前线程名，当前是主线程，子线程执行的代码是在run()方法中执行结果：Main：mainThread-1 12345678910111213public class MultiThread &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start(); System.out.println("Main："+Thread.currentThread().getName()); &#125;&#125;class MyThread extends Thread&#123; @Override public void run()&#123; System.out.println(getName()); &#125;&#125; 五、附加题 简述Http的请求格式，以及GET和POST的区别答：http请求格式：请求行 + 请求头 + 数据体请求行包含三个内容 method + request-URI + http-versionmethod 包含有 post , get, head,delete, put, connect, options, patch, propfind, propatch, mkcol, copy, move, lock, unlock, trace, head GET和POST的区别： GET请求在URL中传送的参数是有长度限制的，而POST没有。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET在浏览器回退时是无害的，而POST会再次提交请求。 其实，GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议。上述的所谓区别，只是浏览器厂家根据约定，做得限制而已。HTTP请求，最初设定了八种方法。这八种方法本质上没有任何区别。只是让请求，更加有语义而已。 OPTIONS 返回服务器所支持的请求方法 GET 向服务器获取指定资源 HEAD 与GET一致，只不过响应体不返回，只返回响应头 POST 向服务器提交数据，数据放在请求体里 PUT 与POST相似，只是具有幂等特性，一般用于更新 DELETE 删除服务器指定资源 TRACE 回显服务器端收到的请求，测试的时候会用到这个 CONNECT 预留，暂无使用 简述一下synchronized同步块和同步方法的原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四川禹慕科技有限公司2019面试题]]></title>
    <url>%2Fp%2F3b16.html</url>
    <content type="text"><![CDATA[面试时间： 2019-4-1 1. Java 面向对象的特征有哪些，请详细阐述 对象的编程语言有封装、继承 、抽象、多态等4个主要的特征 面向对象编程有三大特性：封装、继承、多态 封装： 封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部件的“高内聚、低耦合”，面向对象的编程语言中，对象是封装的最基本单位，面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性抽象： 抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处继承： 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性，因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，这就是多态性多态： 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定 2. abstract class和interface的区别抽象类： 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象 抽象类要被子类继承，接口要被类实现。 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 抽象类里可以没有抽象方法 如果一个类里有抽象方法，那么这个类只能是抽象类 抽象方法要被实现，所以不能是静态的，也不能是私有的。接口： 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 接口可继承接口，并可多继承接口，但类只能单根继承。 3. Java中Heap和Stack的区别stack： 定义：每个应用运行时都有自己的一段内存空间，用于存放临时变量、参数传递、函数调用时的PC值以及对象的引用，这叫stack 优点：存取速度比堆快，仅次于CPU中的寄存器。另外， 缺点：存在栈中的数据的大小与生存期必须是确定的，所以缺乏灵活性。heap： 定义：堆是JVM的内存数据区。Heap的管理很复杂，每次分配不定长的内存空间专门用来保存对象的实例（实际上是保存对象实例的属性值，属性的类型和对象本身的类型标志等），并不保存对象的方法（方法是指令，保存在栈中）。 优点：堆是一个运行时的数据区，它的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，java的垃圾收集器会自动收走这些不再使用的数据。 缺点：由于在运行时动态分配内存，存取速度比较慢。 4. 编程题：写一个 Singleton 出来懒汉式单例12345678910111213141516171819public class LazySingleton &#123; // 私有静态对象,加载时候不做初始化 private static LazySingleton singleton =null; // 私有构造方法,避免外部创建实例 private LazySingleton()&#123; &#125; /** * 静态工厂方法,返回此类的唯一实例. * 当发现实例没有初始化的时候,才初始化. * @return LazySingleton */ public static synchronized LazySingleton getInstance()&#123; if(singleton ==null)&#123; singleton =new LazySingleton(); &#125; return singleton; &#125;&#125; 饿汉式单例12345678910111213141516public class EagerSingleton &#123; // 私有的唯一实例成员,在类加载的时候就创建好了单例对象 private static final EagerSingleton SINGLETON = new EagerSingleton(); //私有构造方法,避免外部创建实例 private EagerSingleton() &#123; &#125; /** * 静态工厂方法,返回此类的唯一实例. * * @return EagerSingleton */ public static EagerSingleton getInstance() &#123; return SINGLETON; &#125;&#125; 5. Jvm加载class文件的原理机制 装载： 查找并加载类的二进制数据； 链接： 验证：确保被加载类的正确性； 准备：为类的静态变量分配内存，并将其初始化为默认值； 解析：把类中的符号引用转换为直接引用； 初始化： 为类的静态变量赋予正确的初始值；6.执行结果：2413 先初始化父类，父类中static依次初始化 子类中static依次初始化 父类变量、代码块依次初始化，再执行父类构造 子类变量、代码块依次初始化，再执行子类构造12345678public class A &#123; public A() &#123; System.out.print(1); &#125; static &#123; System.out.print(2); &#125;&#125; 123456789public class B extends A &#123; public B() &#123; System.out.print(3); &#125; static &#123; System.out.print(4); &#125;&#125; 12345public class C &#123; public static void main(String[] args) &#123; new B(); &#125;&#125; 注意： 静态代码块只执行一次，而代码块每次都执行// 245163// 516312345678910111213141516171819202122232425262728293031class A &#123; public A() &#123; System.out.print(1); &#125; static &#123; System.out.print(2); &#125; &#123; System.out.print(5); &#125;&#125;class B extends A &#123; public B() &#123; System.out.print(3); &#125; static &#123; System.out.print(4); &#125; &#123; System.out.print(6); &#125;&#125;public class C &#123; public static void main(String[] args) &#123; new B(); System.out.println(); new B(); &#125;&#125; 7. 什么是AJAX，你常用的AJAX方式是什么，请具体描述其实现原理AJAX： AJAX不是新的编程语言，而是一种使用现有标准的新方法 优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行 常用方式：$.ajax()、$.get()、$.post()、load() 原理： Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面8. JSP中静态include和动态include的区别静态include是编译阶段的代码拼接，动态include是编译后的servlet的运行结果的拼接9.什么是SSH框架，并具体描述其中应用的技术的主要功能及其实现原理？ SSH是JavaEE中三种框架(Struts+Spring+Hibernate)的集成框架，是目前比较流行的一种Java Web开源框架 原理： 在表示层中，首先通过JSP页面实现交互界面，负责传送请求(Request)和接收响应(Response)，然后Struts根据配置文件(struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。 在业务层中，管理服务组件的Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。 在持久层中，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。10.原理： 在第一步执行完毕后，整个方法的返回值就已经确定了， 由于还要执行finally代码块，因此程序会将返回值暂存在局部变量区，腾出操作数栈用来执行finally语句块中代码， 等finally执行完毕，再将暂存的返回值又复制回操作数栈顶。 所以无论finally语句块中执行了什么操作，都无法影响返回值， 所以试图在finally语句块中修改返回值是徒劳的。 因此，finally语句块设计出来的目的只是为了让方法执行一些重要的收尾工作，而不是用来计算返回值的。 注意：在finally或者cathch中出现了return就有可能更改返回值12345678910111213141516public class A &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(a.getA()); &#125; public int getA() &#123; int a = 0; try &#123; return a; &#125; finally &#123; a = 2; &#125; &#125;&#125; 11. 有如下一段html，请编写css定义，使div1居左，宽度200px；是div2居右，宽度100px，背景颜色为红色123456789101112#div1 &#123; width: 200px; /*居左*/ float: left&#125;#div2 &#123; width: 100px; /*居右*/ float: right; background-color: red;&#125; 1234&lt;div id="thediv"&gt; &lt;div id="div1"&gt;hrer is left&lt;/div&gt; &lt;div id="div2"&gt;hrer is right&lt;/div&gt;&lt;/div&gt; 12.有如下一段html，请用javascript编写change()方法，实现选择不同的tab，只显示对应的div1234567891011function change(sel) &#123; // 先让所有div全部隐藏 var tabs = document.getElementsByTagName("div"); for (var i = 0; i &lt; tabs.length; i++) &#123; tabs[i].setAttribute("style", "display: none"); &#125; // 再选择显示的div var id = sel.options[sel.selectedIndex].value; var tab = document.getElementById(id); tab.setAttribute("style", "display:block");&#125; 12345678&lt;select onchange="change(this)"&gt; &lt;option value="tab1"&gt;tab1&lt;/option&gt; &lt;option value="tab2"&gt;tab2&lt;/option&gt; &lt;option value="tab3"&gt;tab3&lt;/option&gt;&lt;/select&gt;&lt;div id="tab1" style="display: none"&gt;here is tab1&lt;/div&gt;&lt;div id="tab2" style="display: none"&gt;here is tab2&lt;/div&gt;&lt;div id="tab3" style="display: none"&gt;here is tab3&lt;/div&gt; 13. 在一张ORACLE下简历的雇员数据表 t_employee，其结果如下 字段名称 类型 说明 f_id number 员工编号(唯一) f_name varchar(64) 名字 o_dep_id number 所在部门编号 f_join_date date 加入公司时间 o_dep_id number 上司编号(对应员工编号，0表示无上司) 方式一1SELECT t.f_name as 名字,IFNULL((SELECT emp.f_name FROM t_employee emp WHERE emp.f_id=t.o_manager_id),&apos;无&apos;) as 上司 FROM t_employee t WHERE t.f_name LIKE &quot;李%&quot; and t.f_join_date&gt;&quot;2000-09-01&quot;; 方式二12SELECT t_emp.f_name as 名字,IFNULL( emp.f_name,&quot;无&quot;) as 上司 from (SELECT t.f_name,t.o_manager_id FROM t_employee t WHERE t.f_name LIKE &quot;李%&quot; and t.f_join_date&gt;&quot;2000-09-01&quot;) as t_empLEFT JOIN t_employee emp ON t_emp.o_manager_id=emp.f_id; 14. 请编写通过JDBC操作(如查询)数据库的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Jdbc &#123; private static Connection CONNECTION; static &#123; try &#123; // 不需要使用 Class.forName(),因为DriverManager初始化时会自动注册驱动 // 驱动加载路径：jdbc驱动包中的META-INF.services.java.sql.Driver这个文件中有声明 Properties pro = new Properties(); pro.setProperty("user", "root"); pro.setProperty("password", "root"); CONNECTION = DriverManager.getConnection("jdbc:mysql://localhost:3306/cas_redis?useSSL=false&amp;serverTimezone=UTC", pro); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; String sql = "select id,`name`,gender,age,telphone,register_mode,third_party_id from user_info where id=?"; PreparedStatement preStatement = null; try &#123; preStatement = CONNECTION.prepareStatement(sql); preStatement.setInt(1, 1); ResultSet resultSet = preStatement.executeQuery(); while (resultSet.next()) &#123; System.out.printf("%s ", resultSet.getObject("id")); System.out.printf("%s ", resultSet.getObject("name")); System.out.printf("%s ", resultSet.getObject("gender")); System.out.printf("%s ", resultSet.getObject("age")); System.out.printf("%s ", resultSet.getObject("telphone")); System.out.printf("%s ", resultSet.getObject("register_mode")); System.out.printf("%s ", resultSet.getObject("third_party_id")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (preStatement != null) &#123; preStatement.close(); &#125; if (CONNECTION != null) &#123; CONNECTION.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京米纳科技有限公司面试题]]></title>
    <url>%2Fp%2F24fe.html</url>
    <content type="text"><![CDATA[面试时间： 2019-4-20 1. 有一个11位数，如何判断他是否是一个回文数(1234321就是一个回文数) 12345678910111213141516171819202122232425262728public class PalindromeNumber &#123; public static boolean isPalindrome(int num) &#123; String str = String.valueOf(num); for (int i = 0; i &lt; str.length() / 2; i++) &#123; if (str.charAt(i) != str.charAt(str.length() - i - 1)) &#123; return false; &#125; &#125; return true; &#125; public static boolean isPalindrome2(int num) &#123; String str = new StringBuilder(num).reverse().toString(); return str.equals(String.valueOf(num)); &#125; public static boolean isPalindrome3(int num) &#123; if (num &lt; 0 || (num != 0 &amp;&amp; num % 10 == 0)) &#123; return false; &#125; int rev = 0; while (num &gt; rev) &#123; rev = rev * 10 + num % 10; num = num / 10; &#125; return (num == rev || num == rev / 10); &#125;&#125; 2. n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的哪位?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class NRenShu &#123; public int isN(int n) &#123; int m = 3, s = 0; for (int i = 2; i &lt;= n; ++i) &#123; s = (s + m) % i; &#125; return s + 1; &#125; public int isN2(int n) &#123; int i, p = 0, q; int[] a = new int[100]; q = n; // 给数组赋值 1-输入的数字 for (i = 0; i &lt; n; i++) &#123; a[i] = i + 1; &#125; for (i = 0; ; i++) &#123; if (i == n) &#123; //当i++一直到n时，肯定有一些没有被选到，比如我们输入8,第一轮是3,6被赋值0，当i=8时，重置i的值继续下一轮 i = 0; &#125; if (a[i] != 0) &#123; //我们下面定义的是当循环到三时，就赋值0，所以这边等0的不考虑在内 p++; &#125; else &#123; // 此数已经被删除，跳过 continue; &#125; if (p % 3 == 0) &#123; //这个就是从0一直加，到三的倍数就赋值为0，从而就达到我们的目的 a[i] = 0; q--; &#125; //上面q=n;表明q==n,只有一个为0就减一，为下面做铺垫 if (q == 1) &#123; break; //当剩下最后一个就输出 &#125; &#125; int num = -1; for (i = 0; i &lt; n; i++) &#123; if (a[i] != 0) &#123; num = a[i]; break; &#125; &#125; return num; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与SpringMVC的容器冲突解决]]></title>
    <url>%2Fp%2F69d4.html</url>
    <content type="text"><![CDATA[博客园1.在applicationContext.xml中配置:12345&lt;!-- Spring容器中注册非@controller注解的Bean --&gt;&lt;context:component-scan base-package="com.hafiz.www"&gt; &lt;!--排除@Controller--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; 2.applicationContext-MVC.xml中配置1234567&lt;!-- SpringMVC容器中只注册带有@controller注解的Bean --&gt;&lt;!--use-default-filters：默认true 会自动注册对@Component、@ManagedBean、@Named注解的Bean进行扫描 这里改为false让其只扫描@Controller注解--&gt;&lt;context:component-scan base-package="com.hafiz.www" use-default-filters="false"&gt; &lt;!--引入@Controller--&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;&lt;/context:component-scan&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列1,11,21,1211,111221]]></title>
    <url>%2Fp%2Fa79b.html</url>
    <content type="text"><![CDATA[1. 序列1，11，21，1211，111221，_，下一个数是什么？答：312211 1 读为： 1个1，提取数字11（即为第二个数）； 11 读为： 2个1，提取数字21（即为第三个数）； 21 读为： 1个2、1个1，提取数字1211（即为第四个数）； 1211 读为：1个1、1个2、2个1；提取数字111221（即为第四个数）； 2. 编程实现123456789101112131415161718192021222324252627282930313233public class Demo &#123; public static void main(String[] args) &#123; int count = 6; String[] str = new String[count]; str[0] = "1"; str[1] = "11"; int j; StringBuilder result; for (int i = 2; i &lt; count; i++) &#123; char[] pri = str[i - 1].toCharArray(); int n; result = new StringBuilder(); j = 0; for (n = 0; n &lt; pri.length - 1; n++) &#123; if (pri[n] == pri[n + 1]) &#123; j++; &#125; else &#123; j++; result.append(j); result.append(pri[n]); j = 0; &#125; &#125; j++; result.append(j); result.append(pri[n]); str[i] = result.toString(); &#125; for (int i = 1; i &lt;= count; i++) &#123; System.out.println(i + "个数: " + str[i-1]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类中的初始化顺序]]></title>
    <url>%2Fp%2F66fe.html</url>
    <content type="text"><![CDATA[1. 下面详细介绍了类中变量的初始化顺序 1234567891011121314151617181920212223242526272829303132public class Test &#123; // 1.第一步，准备加载类 static int num = 4; // 2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 static &#123; // 3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a System.out.println("a"); &#125; public static void main(String[] args) &#123; new Test(); // 4.第四步，new一个类，但在new之前要处理匿名代码块 &#125; int a = 4; // 5.第五步，按照顺序加载变量和执行匿名代码块 &#123; System.out.println("b"); // 6.第六步，按照顺序加载匿名代码块，代码块中有打印 &#125; int b = 5; // 7.第七步，按照顺序加载变量 &#123; System.out.println("c"); // 8.第八步，按照顺序打印c &#125; Test() &#123; System.out.println("d"); // 9.第久步，最后加载构造函数，完成对象的建立 &#125; static void run() &#123; // 静态方法，调用的时候才加载// 注意看，e没有加载 System.out.println("e"); &#125;&#125; 2. 一个简单的小测试1234567891011121314151617181920212223242526272829303132333435363738public class TestAB &#123; public static void main(String[] args) &#123; // 142356 B b = new B(); &#125;&#125;class A &#123; static int a = 4; static &#123; System.out.print(1); &#125; &#123; System.out.print("2"); &#125; public A() &#123; System.out.print(3); &#125;&#125;class B extends A &#123; static int a = 5; static &#123; System.out.print(4); &#125; &#123; System.out.print("5"); &#125; public B() &#123; System.out.print(6); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8四大内置核心函数式接口]]></title>
    <url>%2Fp%2Fd0ca.html</url>
    <content type="text"><![CDATA[JDK8 中的四大核心函数式接口 @FunctionalInterface标记在接口上，“函数式接口”是指仅仅只包含一个抽象方法的接口1. Consumer：消费型接口 void accpt(T t); 12345678910public class ConsumerTest &#123; @Test public void test() &#123; happy(1000d, (money) -&gt; System.out.println("今天消费了" + money + "元")); &#125; public static void happy(Double money, Consumer&lt;Double&gt; customer) &#123; customer.accept(money); &#125;&#125; 2. Supplier：供给型接口 T get(); 1234567891011121314151617181920212223public class SupplierTest &#123; @Test public void test() &#123; //生成10个100以内的随机数 List&lt;Integer&gt; list = getNumList(10, () -&gt; (int) (Math.random() * 100)); list.forEach(System.out::println); &#125; /** * 产生指定个数的随机数放入集合中并返回 * * @param num 生成随机数的个数 * @param supplier 供给型接口 * @return List */ public static List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; supplier) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; list.add(supplier.get()); &#125; return list; &#125;&#125; 3. Function：函数式接口 R apply(T t); 12345678910111213141516public class FunctionTest &#123; @Test public void test1() &#123; System.out.println(strHandler("hello world !", (str)-&gt;str.toUpperCase())); &#125; @Test public void test2() &#123; // 类::实例方法名 System.out.println(strHandler("hello world !",String::toUpperCase)); &#125; public static String strHandler(String str, Function&lt;String, String&gt; function) &#123; return function.apply(str); &#125;&#125; 4. Predicate：消费型接口 boolean test(T t); 1234567891011121314151617181920212223242526public class PredicateTest &#123; @Test public void test() &#123; List&lt;String&gt; list = Arrays.asList("hello java", "C#", "C++", "jar", "java"); // 判断集合中是否包含 java 包含就添加进新的集合并返回 List&lt;String&gt; stringList = filterStr(list, (str) -&gt; str.contains("java")); stringList.forEach(System.out::println); &#125; /** * 将满足条件的字符串放进新的集合中并返回 * * @param list List * @param predicate 断言型接口 * @return List */ public static List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; predicate) &#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if (predicate.test(str)) &#123; strList.add(str); &#125; &#125; return strList; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finalize方法之对象的自我拯救]]></title>
    <url>%2Fp%2Fc96a.html</url>
    <content type="text"><![CDATA[finalize是Object中的一个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 对象的自我拯救 * 被拯救后的对象信息丢失,但是对象的地址值不变 * * @author ZZQ */public class FinalizeEscapeGC &#123; private String name; public static FinalizeEscapeGC SAVE_HOOK = null; /** * 判断是否还活着 */ public void isAlive() &#123; System.out.println(SAVE_HOOK.name + "还活着"); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("finalize方法执行了"); // 与对象建立联系，自救 FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGC(); SAVE_HOOK.name = "zzq"; System.out.println("被拯救前对象地址值：" + SAVE_HOOK); //第一次自救 SAVE_HOOK = null; System.gc(); //因为finalize的优先级低，先等一下 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("第一次自救失败"); &#125; System.out.println("被拯救后对象地址值：" + SAVE_HOOK); //第二次自救 //因为每个对象的finalize()方法只会被系统自动调用一次，所以第一次调用后， //第二次自救时不会再调用finalize(),自然也就不会与其他的对象产生联系，从而自救失败 SAVE_HOOK = null; System.gc(); //因为finalize的优先级低，先等一下 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println("第二次自救失败"); &#125; &#125; //finalize()虽然能够实现对象自救，但是不要轻易使用，因为他的运行代价太大，不确定性高，无法确定各个对象的调用顺序。 //而且finalize()能做的事，try-finally都能做，而且做得更好&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的4种创建方式]]></title>
    <url>%2Fp%2F424a.html</url>
    <content type="text"><![CDATA[1. 继承Thread类 123456789101112131415public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t = new Thread(myThread); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 2. 实现Runnable接口123456789101112131415public class ThreadDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t = new Thread(myThread); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125;&#125; 3. 使用Callable和Future创建线程123456789101112131415161718public class ThreadDemo &#123; public static void main(String[] args) &#123; MyCallable myCallable = new MyCallable(); FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(myThread); Thread t = new Thread(future); t.start(); System.out.println(Thread.currentThread().getName()); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return 0; &#125;&#125; 4. 使用线程池创建线程1234567891011121314151617181920212223public class ThreadDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 创建一个具有固定大小的线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建一个任务 Callable&lt;Integer&gt; callable = new MyCallable(); // 提交任务 Future future = executorService.submit(callable); // 获取任务执行结果 此方法会阻塞 System.out.println(future.get()); // 关闭线程池 executorService.shutdown(); &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()); return 0; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
